using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Org.BouncyCastle.Utilities.IO.Pem;
using Xunit;
using Xunit.Abstractions;
using PemWriter = Org.BouncyCastle.OpenSsl.PemWriter;

namespace ToolsPack.String.Tests;

public class RsaEncryptionTest
{
    private readonly ITestOutputHelper _testOutputHelper;

    public RsaEncryptionTest(ITestOutputHelper testOutputHelper)
    {
        _testOutputHelper = testOutputHelper;
    }

    /// <summary>
    /// 1. Generate Public/Private Key using OpenSSL command line (checkout the `sample-keys-openssl` folder)
    ///  * create the private key `openssl genrsa -out private.pem 2048`
    ///  * extract the public key from the private key `openssl rsa -in private.pem -outform PEM -pubout -out public.pem`
    /// 2. Use them for encryption:
    ///  * Read the public key from the public.pem file and use it to encrypt a payload
    ///  * Read the private key from the private.pkcs8 file and use it to decrypt the payload
    /// </summary>
    [Fact]
    public async Task AsymmetricEncryption_Using_OpenSsl_GeneratedKey()
    {
        RSAEncryptionPadding padding = RSAEncryptionPadding.OaepSHA256;
        const string payload = "This is a top secret";
        byte[] encryptedPayload;

        //Encrypt the payload with public key
        using (var rsa = RSA.Create())
        {
            //read public key from the PEM file
            var publicKeyPem = await File.ReadAllTextAsync("./sample-keys-openssl/public.pem").ConfigureAwait(false);
            rsa.ImportFromPem(publicKeyPem);

            //use the public key to encrypt the payload
            encryptedPayload = rsa.Encrypt((new UTF8Encoding()).GetBytes(payload),
                padding);
        }

        //Display the payload after encrypted (if you are curious to see what it looks like..)
        _testOutputHelper.WriteLine("the encrypted payload in Base64 format: " + Convert.ToBase64String(encryptedPayload));
        _testOutputHelper.WriteLine("the encrypted payload in Hex format: " + Utf8SealCalculator.ToHex(encryptedPayload));
        
        //Decrypt the payload with private key
        using (var rsa = RSA.Create())
        {
            //read private key from the PEM file
            rsa.ImportFromPem(await File.ReadAllTextAsync("./sample-keys-openssl/private.pem").ConfigureAwait(false));

            //use the private key to decrypt the payload
            Assert.Equal(payload,
                (new UTF8Encoding()).GetString(rsa.Decrypt(encryptedPayload, padding)));
        }
    }
    
    /// <summary>
    /// Complete test scenario: in this example we will generate the private and public key ourself.
    /// * Generate a pair of public key and private key
    /// * Save the public key to a text file (public.pem)
    /// * Save the private key to a binary file (private.pkcs8)
    /// * Save the private key to a text file (private.pem)
    /// * Read the public key from the public.pem file and use it to encrypt a payload
    /// * Read the private key from the private.pem file and use it to decrypt the payload
    /// * Read the private key from the private.pkcs8 file and use it to decrypt the payload
    ///
    /// Each test execution will create a different public/private key pair. An example of
    /// a keys pair is in the sample-keys-autogenerated. 
    /// </summary>
    [Fact]
    public async Task AsymmetricEncryptionTest()
    {
        //Generate a public/private key pair.  
        using (var rsa = RSA.Create())
        {
            //export public key to file in the PEM format (text format make it easier to share)
            await File.WriteAllTextAsync("./public.pem", rsa.ExportToPem(RsaPublicKeyFormat.RsaPublicKey))
                .ConfigureAwait(false);
            
            //export private key to file in the PKCS8 format
            var privateKeyPkcs8 = rsa.ExportPkcs8PrivateKey();
            await File.WriteAllBytesAsync("./private.pkcs8", privateKeyPkcs8).ConfigureAwait(false);

            //export private key to file in the PEM format
            /*
             * We can Base64-encode the privateKeyPkcs8, then write them to a text file:
             * - insert new line for each 64 chars
             * - Add the PEM header and footer
             *
             * Here I used the pemWriter in the BouncyCastle nuget to do it. 
             */
            using var streamWriter = new StreamWriter("./private.pem");
            {
                PemWriter pemWriter = new PemWriter(streamWriter);
                pemWriter.WriteObject(new PemObject("PRIVATE KEY", privateKeyPkcs8));
            }
        }

        RSAEncryptionPadding padding = RSAEncryptionPadding.OaepSHA256;
        const string payload = "This is a top secret";
        byte[] encryptedPayload;

        //Encrypt the payload with public key
        using (var rsa = RSA.Create())
        {
            //read public key from the PEM file
            var publicKeyPem = await File.ReadAllTextAsync("./public.pem").ConfigureAwait(false);
            rsa.ImportFromPem(publicKeyPem);

            //use the public key to encrypt the payload
            encryptedPayload = rsa.Encrypt((new UTF8Encoding()).GetBytes(payload),
                padding);
        }

        //Decrypt the payload with private key
        using (var rsa = RSA.Create())
        {
            //read private key from the PEM file
            rsa.ImportFromPem(await File.ReadAllTextAsync("./private.pem").ConfigureAwait(false));

            //use the private key to decrypt the payload
            Assert.Equal(payload,
                (new UTF8Encoding()).GetString(rsa.Decrypt(encryptedPayload, padding)));

            //read private key from the PKCS8 file
            rsa.ImportPkcs8PrivateKey(await File.ReadAllBytesAsync("./private.pkcs8").ConfigureAwait(false), out _);

            //use the private key to decrypt the payload
            Assert.Equal(payload,
                (new UTF8Encoding()).GetString(rsa.Decrypt(encryptedPayload, padding)));
        }
    }
}